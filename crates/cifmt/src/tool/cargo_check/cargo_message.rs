//! Top-level cargo message types.

use crate::ci::GitHub;
use crate::message::CiMessage;
use serde::{Deserialize, Serialize};

use super::common::{Profile, Target};
use super::rustc_message::RustcMessage;

/// A message from cargo's JSON output.
///
/// These messages are emitted when running cargo commands with
/// `--message-format=json`.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(tag = "reason", rename_all = "kebab-case")]
#[non_exhaustive]
pub enum CargoMessage {
    /// Compiler diagnostic (error, warning, etc.).
    CompilerMessage(CompilerMessage),

    /// Artifact produced by the build.
    CompilerArtifact(CompilerArtifact),

    /// Build script output.
    BuildScriptExecuted(BuildScriptExecuted),

    /// Build finished.
    BuildFinished(BuildFinished),
}

impl CiMessage<GitHub> for CargoMessage {
    fn format(&self) -> String {
        match self {
            Self::CompilerMessage(msg) => msg.format(),
            Self::CompilerArtifact(msg) => msg.format(),
            Self::BuildScriptExecuted(msg) => msg.format(),
            Self::BuildFinished(msg) => msg.format(),
        }
    }
}

/// Compiler message (errors, warnings, notes).
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct CompilerMessage {
    /// The Package ID.
    pub package_id: String,
    /// Absolute path to the package manifest.
    pub manifest_path: String,
    /// The Cargo target that generated the message.
    pub target: Target,
    /// The rustc message from the compiler.
    pub message: RustcMessage,
}

impl CiMessage for CompilerMessage {
    type Platform = GitHub;

    fn format(&self) -> String {
        self.message.format()
    }
}

/// Compiler artifact message.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct CompilerArtifact {
    /// The Package ID.
    pub package_id: String,
    /// Absolute path to the package manifest.
    pub manifest_path: String,
    /// The Cargo target that generated the artifacts.
    pub target: Target,
    /// Build profile information.
    pub profile: Profile,
    /// Array of features enabled.
    pub features: Vec<String>,
    /// Array of files generated by this step.
    pub filenames: Vec<String>,
    /// Path to the executable, if generated.
    pub executable: Option<String>,
    /// Whether artifacts were up-to-date.
    pub fresh: bool,
}

impl CiMessage for CompilerArtifact {
    type Platform = GitHub;

    fn format(&self) -> String {
        if self.fresh {
            GitHub::debug(format!(
                "Artifact up-to-date: {} ({})",
                self.target.name,
                self.target.kind.join(", ")
            ))
        } else {
            GitHub::debug(format!(
                "Built artifact: {} ({})",
                self.target.name,
                self.target.kind.join(", ")
            ))
        }
    }
}

/// Build script execution result.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct BuildScriptExecuted {
    /// The Package ID.
    pub package_id: String,
    /// Libraries to link.
    pub linked_libs: Vec<String>,
    /// Library search paths.
    pub linked_paths: Vec<String>,
    /// Cfg values to enable.
    pub cfgs: Vec<String>,
    /// Environment variables to set.
    pub env: Vec<(String, String)>,
    /// Output directory path.
    pub out_dir: String,
}

impl CiMessage for BuildScriptExecuted {
    type Platform = GitHub;

    fn format(&self) -> String {
        GitHub::debug(format!("Build script executed: {}", self.package_id))
    }
}

/// Build finished message.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct BuildFinished {
    /// Whether the build succeeded.
    pub success: bool,
}

impl CiMessage for BuildFinished {
    type Platform = GitHub;

    fn format(&self) -> String {
        if self.success {
            GitHub::notice("Build finished successfully")
                .title("Build Complete")
                .format()
        } else {
            GitHub::error("Build failed").title("Build Failed").format()
        }
    }
}

#[cfg(test)]
pub mod test_data {
    use super::{BuildFinished, BuildScriptExecuted, CompilerArtifact, CompilerMessage};
    use crate::tool::cargo_check::{Profile, Target, rustc_message::test_data as rustc_data};
    use serde_json::json;

    /// Test data for build finished messages.
    pub fn build_finished_cases()
    -> impl Iterator<Item = (&'static str, serde_json::Value, BuildFinished)> {
        [
            (
                "build_finished_success",
                json!({
                    "reason": "build-finished",
                    "success": true,
                }),
                BuildFinished { success: true },
            ),
            (
                "build_finished_failure",
                json!({
                    "reason": "build-finished",
                    "success": false,
                }),
                BuildFinished { success: false },
            ),
        ]
        .into_iter()
    }

    /// Test data for build script executed messages.
    pub fn build_script_cases()
    -> impl Iterator<Item = (&'static str, serde_json::Value, BuildScriptExecuted)> {
        [(
            "build_script_executed",
            json!({
                "reason": "build-script-executed",
                "package_id": "example 0.1.0 (path+file:///path/to/example)",
                "linked_libs": ["ssl", "crypto"],
                "linked_paths": ["/usr/lib", "/usr/local/lib"],
                "cfgs": ["feature=\"ssl\""],
                "env": [["OUT_DIR", "/path/to/out"]],
                "out_dir": "/path/to/out",
            }),
            BuildScriptExecuted {
                package_id: "example 0.1.0 (path+file:///path/to/example)".to_string(),
                linked_libs: vec!["ssl".to_string(), "crypto".to_string()],
                linked_paths: vec!["/usr/lib".to_string(), "/usr/local/lib".to_string()],
                cfgs: vec!["feature=\"ssl\"".to_string()],
                env: vec![("OUT_DIR".to_string(), "/path/to/out".to_string())],
                out_dir: "/path/to/out".to_string(),
            },
        )]
        .into_iter()
    }

    /// Test data for compiler artifact messages.
    pub fn compiler_artifact_cases()
    -> impl Iterator<Item = (&'static str, serde_json::Value, CompilerArtifact)> {
        use std::path::PathBuf;

        [
            (
                "compiler_artifact_fresh",
                json!({
                    "reason": "compiler-artifact",
                    "package_id": "example 0.1.0 (path+file:///path/to/example)",
                    "manifest_path": "/path/to/example/Cargo.toml",
                    "target": {
                        "kind": ["lib"],
                        "crate_types": ["lib"],
                        "name": "example",
                        "src_path": "/path/to/example/src/lib.rs",
                        "edition": "2021",
                        "doc": true,
                        "doctest": true,
                        "test": true,
                    },
                    "profile": {
                        "opt_level": "0",
                        "debuginfo": 2,
                        "debug_assertions": true,
                        "overflow_checks": true,
                        "test": false,
                    },
                    "features": [],
                    "filenames": ["/path/to/example/target/debug/libexample.rlib"],
                    "executable": null,
                    "fresh": true,
                }),
                CompilerArtifact {
                    package_id: "example 0.1.0 (path+file:///path/to/example)".to_string(),
                    manifest_path: "/path/to/example/Cargo.toml".to_string(),
                    target: Target {
                        kind: vec!["lib".to_string()],
                        crate_types: vec!["lib".to_string()],
                        name: "example".to_string(),
                        src_path: PathBuf::from("/path/to/example/src/lib.rs"),
                        edition: "2021".to_string(),
                        required_features: vec![],
                        doc: true,
                        doctest: true,
                        test: true,
                    },
                    profile: Profile {
                        opt_level: "0".to_string(),
                        debuginfo: Some(serde_json::json!(2)),
                        debug_assertions: true,
                        overflow_checks: true,
                        test: false,
                    },
                    features: vec![],
                    filenames: vec!["/path/to/example/target/debug/libexample.rlib".to_string()],
                    executable: None,
                    fresh: true,
                },
            ),
            (
                "compiler_artifact_built",
                json!({
                    "reason": "compiler-artifact",
                    "package_id": "example 0.1.0 (path+file:///path/to/example)",
                    "manifest_path": "/path/to/example/Cargo.toml",
                    "target": {
                        "kind": ["bin"],
                        "crate_types": ["bin"],
                        "name": "example",
                        "src_path": "/path/to/example/src/main.rs",
                        "edition": "2021",
                        "doc": true,
                        "doctest": false,
                        "test": true,
                    },
                    "profile": {
                        "opt_level": "0",
                        "debuginfo": 2,
                        "debug_assertions": true,
                        "overflow_checks": true,
                        "test": false,
                    },
                    "features": ["default"],
                    "filenames": ["/path/to/example/target/debug/example"],
                    "executable": "/path/to/example/target/debug/example",
                    "fresh": false,
                }),
                CompilerArtifact {
                    package_id: "example 0.1.0 (path+file:///path/to/example)".to_string(),
                    manifest_path: "/path/to/example/Cargo.toml".to_string(),
                    target: Target {
                        kind: vec!["bin".to_string()],
                        crate_types: vec!["bin".to_string()],
                        name: "example".to_string(),
                        src_path: PathBuf::from("/path/to/example/src/main.rs"),
                        edition: "2021".to_string(),
                        required_features: vec![],
                        doc: true,
                        doctest: false,
                        test: true,
                    },
                    profile: Profile {
                        opt_level: "0".to_string(),
                        debuginfo: Some(serde_json::json!(2)),
                        debug_assertions: true,
                        overflow_checks: true,
                        test: false,
                    },
                    features: vec!["default".to_string()],
                    filenames: vec!["/path/to/example/target/debug/example".to_string()],
                    executable: Some("/path/to/example/target/debug/example".to_string()),
                    fresh: false,
                },
            ),
        ]
        .into_iter()
    }

    /// Test data for compiler message messages.
    pub fn compiler_message_cases()
    -> impl Iterator<Item = (&'static str, serde_json::Value, CompilerMessage)> {
        use std::path::PathBuf;

        // Get the first rustc message case for embedding
        let (_rustc_desc, rustc_json, rustc_msg) =
            rustc_data::rustc_message_cases().next().unwrap();

        [(
            "compiler_message",
            json!({
                "reason": "compiler-message",
                "package_id": "example 0.1.0 (path+file:///path/to/example)",
                "manifest_path": "/path/to/example/Cargo.toml",
                "target": {
                    "kind": ["lib"],
                    "crate_types": ["lib"],
                    "name": "example",
                    "src_path": "/path/to/example/src/lib.rs",
                    "edition": "2021",
                    "doc": true,
                    "doctest": true,
                    "test": true,
                },
                "message": rustc_json,
            }),
            CompilerMessage {
                package_id: "example 0.1.0 (path+file:///path/to/example)".to_string(),
                manifest_path: "/path/to/example/Cargo.toml".to_string(),
                target: Target {
                    kind: vec!["lib".to_string()],
                    crate_types: vec!["lib".to_string()],
                    name: "example".to_string(),
                    src_path: PathBuf::from("/path/to/example/src/lib.rs"),
                    edition: "2021".to_string(),
                    required_features: vec![],
                    doc: true,
                    doctest: true,
                    test: true,
                },
                message: rustc_msg,
            },
        )]
        .into_iter()
    }
}

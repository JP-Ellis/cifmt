//! Compiler artifact messages and helpers.
//!
//! This module provides the `CompilerArtifact` type which represents the
//! `"compiler-artifact"` JSON message emitted by Cargo when it produces a
//! build artifact (library, binary, etc.). The struct holds metadata about
//! the artifact such as the producing target, build profile, feature set,
//! and generated filenames.
use serde::Deserialize;

use crate::{
    ci::{GitHub, Plain},
    ci_message::CiMessage,
    tool::cargo_check::common::{Profile, Target},
};

/// Compiler artifact message.
#[derive(Debug, Clone, PartialEq, Deserialize)]
pub struct CompilerArtifact {
    /// The Package ID.
    pub package_id: String,
    /// Absolute path to the package manifest.
    pub manifest_path: String,
    /// The Cargo target that generated the artifacts.
    pub target: Target,
    /// Build profile information.
    pub profile: Profile,
    /// Array of features enabled.
    pub features: Vec<String>,
    /// Array of files generated by this step.
    pub filenames: Vec<String>,
    /// Path to the executable, if generated.
    pub executable: Option<String>,
    /// Whether artifacts were up-to-date.
    pub fresh: bool,
}

impl CiMessage<Plain> for CompilerArtifact {
    fn format(&self) -> String {
        if self.fresh {
            format!(
                "Artifact up-to-date: {} ({})",
                self.target.name,
                self.target.kind.join(", ")
            )
        } else {
            format!(
                "Built artifact: {} ({})",
                self.target.name,
                self.target.kind.join(", ")
            )
        }
    }
}

impl CiMessage<GitHub> for CompilerArtifact {
    fn format(&self) -> String {
        if self.fresh {
            GitHub::debug(format!(
                "Artifact up-to-date: {} ({})",
                self.target.name,
                self.target.kind.join(", ")
            ))
        } else {
            GitHub::debug(format!(
                "Built artifact: {} ({})",
                self.target.name,
                self.target.kind.join(", ")
            ))
        }
    }
}

#[cfg(test)]
pub(crate) mod tests {
    use super::CompilerArtifact;
    use crate::tool::cargo_check::common;
    use serde_json::json;

    /// Test data for compiler artifact messages.
    pub fn cases() -> impl Iterator<Item = (String, serde_json::Value, CompilerArtifact)> {
        common::tests::target_cases().flat_map(move |(target_desc, target_json, target)| {
            common::tests::profile_cases().flat_map(move |(profile_desc, profile_json, profile)| {
                [
                    (
                        format!("compiler_artifact_fresh_{target_desc}_{profile_desc}"),
                        json!({
                            "reason": "compiler-artifact",
                            "package_id": "mypackage 0.1.0 (path+file:///path/to/package)",
                            "manifest_path": "/path/to/package/Cargo.toml",
                            "target": target_json.clone(),
                            "profile": profile_json,
                            "features": ["feature1", "feature2"],
                            "filenames": ["/path/to/target/debug/mylib.rlib"],
                            "executable": null,
                            "fresh": true,
                        }),
                        CompilerArtifact {
                            package_id: "mypackage 0.1.0 (path+file:///path/to/package)".to_owned(),
                            manifest_path: "/path/to/package/Cargo.toml".to_owned(),
                            target: target.clone(),
                            profile: profile.clone(),
                            features: vec!["feature1".to_owned(), "feature2".to_owned()],
                            filenames: vec!["/path/to/target/debug/mylib.rlib".to_owned()],
                            executable: None,
                            fresh: true,
                        },
                    ),
                    (
                        format!("compiler_artifact_built_{target_desc}_{profile_desc}"),
                        json!({
                            "reason": "compiler-artifact",
                            "package_id": "mypackage 0.1.0 (path+file:///path/to/package)",
                            "manifest_path": "/path/to/package/Cargo.toml",
                            "target": target_json.clone(),
                            "profile": profile_json,
                            "features": [],
                            "filenames": ["/path/to/target/debug/myapp"],
                            "executable": "/path/to/target/debug/myapp",
                            "fresh": false,
                        }),
                        CompilerArtifact {
                            package_id: "mypackage 0.1.0 (path+file:///path/to/package)".to_owned(),
                            manifest_path: "/path/to/package/Cargo.toml".to_owned(),
                            target: target.clone(),
                            profile,
                            features: vec![],
                            filenames: vec!["/path/to/target/debug/myapp".to_owned()],
                            executable: Some("/path/to/target/debug/myapp".to_owned()),
                            fresh: false,
                        },
                    ),
                ]
            })
        })
    }
}
